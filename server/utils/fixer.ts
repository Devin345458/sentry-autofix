import { execFile, spawn } from 'child_process'
import { promisify } from 'util'
import { existsSync, mkdirSync, createWriteStream } from 'fs'
import path from 'path'
import type { ParsedEvent } from './parser'
import type { ProjectConfig } from './db'

const execFileAsync = promisify(execFile)

// Resolve Claude CLI binary: use explicit path from config, or find it in node_modules
function resolveClaudeBin(configPath: string): string {
  if (configPath) return configPath

  // Try common locations relative to process.cwd()
  const candidates = [
    path.resolve(process.cwd(), 'node_modules', '.bin', 'claude'),
    path.resolve(process.cwd(), '..', 'node_modules', '.bin', 'claude'),
  ]
  for (const candidate of candidates) {
    if (existsSync(candidate)) return candidate
  }

  // Fallback to PATH
  return 'claude'
}

export interface FixResult {
  success: boolean
  reason?: string
  branch?: string
  changedFiles?: string[]
  claudeOutput?: string
}

interface FixIssueParams {
  parsed: ParsedEvent
  projectConfig: ProjectConfig
  reposDir: string
  claudeCodePath: string
  claudeModel: string
  onLog: (source: string, message: string) => void
}

/**
 * Clone or update the repo, then use Claude Code CLI to analyze
 * the Sentry error and produce a fix.
 */
export async function fixIssue(params: FixIssueParams): Promise<FixResult> {
  const { parsed, projectConfig, reposDir, claudeCodePath, claudeModel, onLog } = params
  const repoDir = path.join(reposDir, projectConfig.repo.replace('/', '__'))
  const branch = `sentry-autofix/${parsed.issueId}`

  // 1. Clone or pull the repo
  onLog('git', `Cloning/updating repo ${projectConfig.repo}...`)
  await ensureRepo(projectConfig.repo, projectConfig.branch, repoDir)

  // 2. Create a fresh branch from the default branch
  onLog('git', `Checking out ${projectConfig.branch} and pulling latest...`)
  await git(repoDir, ['checkout', projectConfig.branch])
  await git(repoDir, ['pull', 'origin', projectConfig.branch])
  try {
    await git(repoDir, ['branch', '-D', branch])
  } catch {
    // branch doesn't exist yet, that's fine
  }
  onLog('git', `Creating branch ${branch}...`)
  await git(repoDir, ['checkout', '-b', branch])

  // 3. Build the prompt for Claude Code
  const prompt = buildPrompt(parsed, projectConfig, repoDir)

  // 4. Run Claude Code CLI in the repo directory
  const claudeBin = resolveClaudeBin(claudeCodePath)
  onLog('claude', `Running Claude Code (${claudeModel}) via ${claudeBin}...`)
  console.log(`[fixer] Running Claude Code (${claudeModel}) via ${claudeBin} for issue ${parsed.issueId}...`)
  const claudeOutput = await runClaudeCode(repoDir, prompt, claudeBin, claudeModel, onLog, parsed.issueId)
  onLog('claude', 'Claude Code finished.')
  console.log(`[fixer] Claude Code finished for issue ${parsed.issueId}`)

  // 5. Check what actually changed via git
  const { stdout: diffFiles } = await git(repoDir, ['diff', '--name-only'])
  const changedFiles = diffFiles.trim().split('\n').filter(Boolean)

  if (changedFiles.length === 0) {
    onLog('result', 'No files changed.')
    console.log(`[fixer] No files changed for issue ${parsed.issueId}`)
    return { success: false, reason: 'no_changes' }
  }

  // 6. Stage and commit
  onLog('git', 'Committing changes...')
  await git(repoDir, ['add', '-A'])
  await git(repoDir, [
    'commit',
    '-m',
    `fix: auto-fix Sentry issue ${parsed.issueId}\n\n${parsed.title}\n\nSentry Issue: ${parsed.webUrl || parsed.issueUrl || 'N/A'}\nGenerated by sentry-autofix using Claude Code (${claudeModel})`,
  ])

  // 7. Push the branch
  onLog('git', `Pushing branch ${branch}...`)
  await git(repoDir, ['push', 'origin', branch, '--force-with-lease'])

  onLog('result', `Changed files: ${changedFiles.join(', ')}`)

  return {
    success: true,
    branch,
    changedFiles,
    claudeOutput,
  }
}

// Strip backticks from Sentry data to prevent breaking prompt formatting
function sanitize(str: string): string {
  return str.replace(/`/g, "'")
}

function buildPrompt(parsed: ParsedEvent, projectConfig: ProjectConfig, repoDir: string): string {
  let prompt = `Fix a production bug in this ${projectConfig.language}/${projectConfig.framework} project.\n\n`
  prompt += `## Working Directory\nThe repository is cloned at: ${repoDir}\nAll file paths in the stack trace are relative to this directory.\n\n`

  prompt += `## Error\n`
  prompt += `Title: ${sanitize(parsed.title)}\n`
  prompt += `Level: ${parsed.level}\n`

  if (parsed.culprit) {
    prompt += `Culprit: ${sanitize(parsed.culprit)}\n`
  }
  if (parsed.message && parsed.message !== parsed.title) {
    prompt += `Message: ${sanitize(parsed.message)}\n`
  }

  if (parsed.stacktrace) {
    prompt += `\n## Stack Trace\n`
    for (const ex of parsed.stacktrace) {
      prompt += `${sanitize(ex.type)}: ${sanitize(ex.value)}\n`
      const appFrames = ex.frames.filter((f) => f.inApp)
      const frames = appFrames.length > 0 ? appFrames : ex.frames.slice(-10)
      for (const frame of frames) {
        prompt += `  at ${sanitize(frame.function || '?')} (${sanitize(frame.filename)}:${frame.lineNo})\n`
        if (frame.context) {
          prompt += `    > ${sanitize(frame.context)}\n`
        }
      }
    }
  }

  if (parsed.request) {
    prompt += `\n## HTTP Request\n${parsed.request.method} ${sanitize(parsed.request.url)}\n`
  }

  prompt += `\n## Instructions\n`
  prompt += `You are running inside the target repository at ${repoDir}. This is the project that has the bug.\n`
  prompt += `- Use the Glob and Grep tools to find the files referenced in the stack trace.\n`
  prompt += `- Read those files to understand the code around the error.\n`
  prompt += `- Use the Edit tool to fix the root cause of this error directly in the source files.\n`
  prompt += `- Do not add new dependencies.\n`
  prompt += `- Do not just describe the fix — you MUST edit the files to apply it.\n`
  prompt += `- If you cannot find the relevant files or confidently fix the issue, make no changes.\n`

  return prompt
}

/**
 * Run Claude Code CLI in the given directory with the prompt.
 * Returns the CLI output text.
 */
async function runClaudeCode(
  cwd: string,
  prompt: string,
  claudeCodePath: string,
  claudeModel: string,
  onLog: (source: string, message: string) => void,
  issueId: string
): Promise<string> {
  return new Promise((resolve, reject) => {
    const args = [
      '--print',
      '--output-format', 'stream-json',
      '--verbose',
      '--include-partial-messages',
      '--model', claudeModel,
      '--max-turns', '15',
      '--allowedTools', 'Read,Glob,Grep,Edit,Write',
      prompt,
    ]

    // Raw log file for debugging
    const logsDir = path.join(cwd, '..', 'claude-logs')
    if (!existsSync(logsDir)) mkdirSync(logsDir, { recursive: true })
    const logFile = createWriteStream(path.join(logsDir, `${issueId}-${Date.now()}.log`))
    logFile.write(`=== Claude Code Run ===\n`)
    logFile.write(`Issue: ${issueId}\n`)
    logFile.write(`Model: ${claudeModel}\n`)
    logFile.write(`Time: ${new Date().toISOString()}\n`)
    logFile.write(`CWD: ${cwd}\n`)
    logFile.write(`Prompt:\n${prompt}\n`)
    logFile.write(`${'='.repeat(60)}\n\n`)

    let resultText = ''
    let stderr = ''
    let stdoutBuffer = ''
    let stderrBuffer = ''

    onLog('claude', `Spawning: ${claudeCodePath} --print --model ${claudeModel} ...`)
    onLog('claude', `Prompt: ${prompt} ...`)

    const proc = spawn(claudeCodePath, args, {
      cwd,
      timeout: 600_000,
      env: {
        ...process.env,
        PATH: process.env.PATH,
      },
    })

    onLog('claude', `Process started (PID ${proc.pid})`)

    proc.stdout.on('data', (data: Buffer) => {
      logFile.write(data)
      stdoutBuffer += data.toString()
      const lines = stdoutBuffer.split('\n')
      stdoutBuffer = lines.pop() || ''
      for (const line of lines) {
        if (!line.trim()) continue
        try {
          const event = JSON.parse(line)
          parseClaudeEvent(event, onLog)
          // Capture final result text
          if (event.type === 'result' && event.result) {
            resultText = event.result
          }
        } catch {
          // Non-JSON line, log it as-is
          onLog('claude', line)
        }
      }
    })

    proc.stderr.on('data', (data: Buffer) => {
      logFile.write(`[stderr] ${data}`)
      const chunk = data.toString()
      stderr += chunk
      stderrBuffer += chunk
      const lines = stderrBuffer.split('\n')
      stderrBuffer = lines.pop() || ''
      for (const line of lines) {
        if (line.trim()) onLog('claude-stderr', line)
      }
    })

    proc.on('close', (code: number | null, signal: string | null) => {
      // Flush remaining buffers
      if (stdoutBuffer.trim()) {
        try {
          const event = JSON.parse(stdoutBuffer)
          parseClaudeEvent(event, onLog)
          if (event.type === 'result' && event.result) resultText = event.result
        } catch {
          onLog('claude', stdoutBuffer)
        }
      }
      if (stderrBuffer.trim()) onLog('claude-stderr', stderrBuffer)

      // Log exit details
      if (signal) {
        onLog('claude', `Process killed by signal ${signal} (likely timeout)`)
      }
      if (code !== null && code !== 0) {
        onLog('claude', `Process exited with code ${code}`)
      }
      if (stderr.trim()) {
        // Log full stderr so user can see what went wrong
        onLog('claude-stderr', stderr.trim())
      }
      if (!resultText && !signal && code === 0) {
        onLog('claude', 'Process exited cleanly but produced no result')
      }

      logFile.write(`\n=== Process exited (code=${code}, signal=${signal}) ===\n`)
      logFile.end()
      resolve(resultText)
    })

    proc.on('error', (err: Error) => {
      onLog('error', `Failed to run Claude Code: ${err.message}`)
      reject(new Error(`Failed to run Claude Code: ${err.message}`))
    })
  })
}

// Track partial tool_use inputs as they stream in
const pendingToolUse = { name: null as string | null, inputJson: '' }

function parseClaudeEvent(event: any, onLog: (source: string, message: string) => void): void {
  // --- Streaming delta events (from --verbose --include-partial-messages) ---
  if (event.type === 'stream_event') {
    const inner = event.event || {}

    // content_block_start: a new content block begins (text or tool_use)
    if (inner.type === 'content_block_start' && inner.content_block) {
      const block = inner.content_block
      if (block.type === 'tool_use') {
        pendingToolUse.name = block.name || null
        pendingToolUse.inputJson = ''
      }
    }

    // content_block_delta: streaming text or tool input
    if (inner.type === 'content_block_delta' && inner.delta) {
      // We don't log text deltas individually — too noisy
      // But we accumulate tool input JSON
      if (inner.delta.type === 'input_json_delta' && inner.delta.partial_json) {
        pendingToolUse.inputJson += inner.delta.partial_json
      }
    }

    // content_block_stop: block is complete — log tool calls here
    if (inner.type === 'content_block_stop') {
      if (pendingToolUse.name) {
        logToolUse(pendingToolUse.name, pendingToolUse.inputJson, onLog)
        pendingToolUse.name = null
        pendingToolUse.inputJson = ''
      }
    }

    return
  }

  // --- Complete message events (non-streaming fallback) ---
  if (event.type === 'message' && event.message?.content) {
    for (const block of event.message.content) {
      if (block.type === 'tool_use') {
        logToolUse(block.name, JSON.stringify(block.input || {}), onLog)
      } else if (block.type === 'text' && block.text) {
        const text = block.text.length > 200 ? block.text.slice(0, 200) + '...' : block.text
        onLog('claude', text)
      }
    }
    return
  }

  // --- Final result ---
  if (event.type === 'result') {
    const cost = event.cost_usd ? `$${event.cost_usd.toFixed(4)}` : ''
    const duration = event.duration_ms ? `${(event.duration_ms / 1000).toFixed(1)}s` : ''
    const parts = [cost, duration].filter(Boolean).join(', ')
    if (parts) onLog('claude', `Done (${parts})`)
  }
}

function logToolUse(name: string, inputJson: string, onLog: (source: string, message: string) => void): void {
  let input: any = {}
  try { input = JSON.parse(inputJson) } catch { /* partial or empty */ }

  if (name === 'Read') {
    onLog('claude', `Reading: ${input.file_path || 'file'}`)
  } else if (name === 'Edit') {
    onLog('claude', `Editing: ${input.file_path || 'file'}`)
  } else if (name === 'Write') {
    onLog('claude', `Writing: ${input.file_path || 'file'}`)
  } else if (name === 'Glob') {
    onLog('claude', `Searching files: ${input.pattern || ''}`)
  } else if (name === 'Grep') {
    onLog('claude', `Searching for: ${input.pattern || ''}`)
  } else {
    onLog('claude', `Tool: ${name}`)
  }
}

async function ensureRepo(repo: string, defaultBranch: string, repoDir: string): Promise<void> {
  if (existsSync(path.join(repoDir, '.git'))) {
    await git(repoDir, ['fetch', 'origin'])
  } else {
    console.log(`[fixer] Cloning ${repo}...`)
    await execFileAsync('gh', ['repo', 'clone', repo, repoDir, '--', '-b', defaultBranch], {
      timeout: 120_000,
    })
  }
}

function git(cwd: string, args: string[]) {
  return execFileAsync('git', args, { cwd, timeout: 60_000 })
}
