import { execFile, spawn } from 'child_process'
import { promisify } from 'util'
import { existsSync } from 'fs'
import path from 'path'
import type { ParsedEvent } from './parser'
import type { ProjectConfig } from './db'

const execFileAsync = promisify(execFile)

export interface FixResult {
  success: boolean
  reason?: string
  branch?: string
  changedFiles?: string[]
  claudeOutput?: string
}

interface FixIssueParams {
  parsed: ParsedEvent
  projectConfig: ProjectConfig
  reposDir: string
  claudeCodePath: string
  claudeModel: string
  onLog: (source: string, message: string) => void
}

/**
 * Clone or update the repo, then use Claude Code CLI to analyze
 * the Sentry error and produce a fix.
 */
export async function fixIssue(params: FixIssueParams): Promise<FixResult> {
  const { parsed, projectConfig, reposDir, claudeCodePath, claudeModel, onLog } = params
  const repoDir = path.join(reposDir, projectConfig.repo.replace('/', '__'))
  const branch = `sentry-autofix/${parsed.issueId}`

  // 1. Clone or pull the repo
  onLog('git', `Cloning/updating repo ${projectConfig.repo}...`)
  await ensureRepo(projectConfig.repo, projectConfig.branch, repoDir)

  // 2. Create a fresh branch from the default branch
  onLog('git', `Checking out ${projectConfig.branch} and pulling latest...`)
  await git(repoDir, ['checkout', projectConfig.branch])
  await git(repoDir, ['pull', 'origin', projectConfig.branch])
  try {
    await git(repoDir, ['branch', '-D', branch])
  } catch {
    // branch doesn't exist yet, that's fine
  }
  onLog('git', `Creating branch ${branch}...`)
  await git(repoDir, ['checkout', '-b', branch])

  // 3. Build the prompt for Claude Code
  const prompt = buildPrompt(parsed, projectConfig)

  // 4. Run Claude Code CLI in the repo directory
  onLog('claude', `Running Claude Code (${claudeModel})...`)
  console.log(`[fixer] Running Claude Code (${claudeModel}) for issue ${parsed.issueId}...`)
  const claudeOutput = await runClaudeCode(repoDir, prompt, claudeCodePath, claudeModel, onLog)
  onLog('claude', 'Claude Code finished.')
  console.log(`[fixer] Claude Code finished for issue ${parsed.issueId}`)

  // 5. Check what actually changed via git
  const { stdout: diffFiles } = await git(repoDir, ['diff', '--name-only'])
  const changedFiles = diffFiles.trim().split('\n').filter(Boolean)

  if (changedFiles.length === 0) {
    onLog('result', 'No files changed.')
    console.log(`[fixer] No files changed for issue ${parsed.issueId}`)
    return { success: false, reason: 'no_changes' }
  }

  // 6. Stage and commit
  onLog('git', 'Committing changes...')
  await git(repoDir, ['add', '-A'])
  await git(repoDir, [
    'commit',
    '-m',
    `fix: auto-fix Sentry issue ${parsed.issueId}\n\n${parsed.title}\n\nSentry Issue: ${parsed.webUrl || parsed.issueUrl || 'N/A'}\nGenerated by sentry-autofix using Claude Code (${claudeModel})`,
  ])

  // 7. Push the branch
  onLog('git', `Pushing branch ${branch}...`)
  await git(repoDir, ['push', 'origin', branch, '--force-with-lease'])

  onLog('result', `Changed files: ${changedFiles.join(', ')}`)

  return {
    success: true,
    branch,
    changedFiles,
    claudeOutput,
  }
}

function buildPrompt(parsed: ParsedEvent, projectConfig: ProjectConfig): string {
  let prompt = `Fix a production bug in this ${projectConfig.language}/${projectConfig.framework} project.\n\n`

  prompt += `## Error\n`
  prompt += `**Title:** ${parsed.title}\n`
  prompt += `**Level:** ${parsed.level}\n`

  if (parsed.culprit) {
    prompt += `**Culprit:** ${parsed.culprit}\n`
  }
  if (parsed.message && parsed.message !== parsed.title) {
    prompt += `**Message:** ${parsed.message}\n`
  }

  if (parsed.stacktrace) {
    prompt += `\n## Stack Trace\n\`\`\`\n`
    for (const ex of parsed.stacktrace) {
      prompt += `${ex.type}: ${ex.value}\n`
      const appFrames = ex.frames.filter((f) => f.inApp)
      const frames = appFrames.length > 0 ? appFrames : ex.frames.slice(-10)
      for (const frame of frames) {
        prompt += `  at ${frame.function || '?'} (${frame.filename}:${frame.lineNo})\n`
        if (frame.context) {
          prompt += `    > ${frame.context}\n`
        }
      }
    }
    prompt += `\`\`\`\n`
  }

  if (parsed.request) {
    prompt += `\n## HTTP Request\n${parsed.request.method} ${parsed.request.url}\n`
  }

  prompt += `\n## Instructions\n`
  prompt += `- Read the relevant source files from the stack trace above.\n`
  prompt += `- Identify and fix the root cause of this error.\n`
  prompt += `- Edit the files directly to apply your fix.\n`
  prompt += `- Do not add new dependencies.\n`
  prompt += `- If you cannot confidently fix the issue, make no changes.\n`

  return prompt
}

/**
 * Run Claude Code CLI in the given directory with the prompt.
 * Returns the CLI output text.
 */
async function runClaudeCode(
  cwd: string,
  prompt: string,
  claudeCodePath: string,
  claudeModel: string,
  onLog: (source: string, message: string) => void
): Promise<string> {
  return new Promise((resolve, reject) => {
    const args = [
      '--print',
      '--output-format', 'stream-json',
      '--verbose',
      '--include-partial-messages',
      '--model', claudeModel,
      '--allowedTools', 'Read,Glob,Grep,Edit,Write',
      prompt,
    ]

    let resultText = ''
    let stderr = ''
    let stdoutBuffer = ''
    let stderrBuffer = ''

    const proc = spawn(claudeCodePath, args, {
      cwd,
      timeout: 600_000,
      env: {
        ...process.env,
        PATH: process.env.PATH,
      },
    })

    proc.stdout.on('data', (data: Buffer) => {
      stdoutBuffer += data.toString()
      const lines = stdoutBuffer.split('\n')
      stdoutBuffer = lines.pop() || ''
      for (const line of lines) {
        if (!line.trim()) continue
        try {
          const event = JSON.parse(line)
          parseClaudeEvent(event, onLog)
          // Capture final result text
          if (event.type === 'result' && event.result) {
            resultText = event.result
          }
        } catch {
          // Non-JSON line, log it as-is
          onLog('claude', line)
        }
      }
    })

    proc.stderr.on('data', (data: Buffer) => {
      const chunk = data.toString()
      stderr += chunk
      stderrBuffer += chunk
      const lines = stderrBuffer.split('\n')
      stderrBuffer = lines.pop() || ''
      for (const line of lines) {
        if (line.trim()) onLog('claude-stderr', line)
      }
    })

    proc.on('close', (code: number | null) => {
      // Flush remaining buffers
      if (stdoutBuffer.trim()) {
        try {
          const event = JSON.parse(stdoutBuffer)
          parseClaudeEvent(event, onLog)
          if (event.type === 'result' && event.result) resultText = event.result
        } catch {
          onLog('claude', stdoutBuffer)
        }
      }
      if (stderrBuffer.trim()) onLog('claude-stderr', stderrBuffer)
      if (code !== 0) {
        console.warn(`[fixer] Claude Code stderr: ${stderr}`)
      }
      resolve(resultText)
    })

    proc.on('error', (err: Error) => {
      onLog('error', `Failed to run Claude Code: ${err.message}`)
      reject(new Error(`Failed to run Claude Code: ${err.message}`))
    })
  })
}

// Track partial tool_use inputs as they stream in
const pendingToolUse = { name: null as string | null, inputJson: '' }

function parseClaudeEvent(event: any, onLog: (source: string, message: string) => void): void {
  // --- Streaming delta events (from --verbose --include-partial-messages) ---
  if (event.type === 'stream_event') {
    const inner = event.event || {}

    // content_block_start: a new content block begins (text or tool_use)
    if (inner.type === 'content_block_start' && inner.content_block) {
      const block = inner.content_block
      if (block.type === 'tool_use') {
        pendingToolUse.name = block.name || null
        pendingToolUse.inputJson = ''
      }
    }

    // content_block_delta: streaming text or tool input
    if (inner.type === 'content_block_delta' && inner.delta) {
      // We don't log text deltas individually — too noisy
      // But we accumulate tool input JSON
      if (inner.delta.type === 'input_json_delta' && inner.delta.partial_json) {
        pendingToolUse.inputJson += inner.delta.partial_json
      }
    }

    // content_block_stop: block is complete — log tool calls here
    if (inner.type === 'content_block_stop') {
      if (pendingToolUse.name) {
        logToolUse(pendingToolUse.name, pendingToolUse.inputJson, onLog)
        pendingToolUse.name = null
        pendingToolUse.inputJson = ''
      }
    }

    return
  }

  // --- Complete message events (non-streaming fallback) ---
  if (event.type === 'message' && event.message?.content) {
    for (const block of event.message.content) {
      if (block.type === 'tool_use') {
        logToolUse(block.name, JSON.stringify(block.input || {}), onLog)
      } else if (block.type === 'text' && block.text) {
        const text = block.text.length > 200 ? block.text.slice(0, 200) + '...' : block.text
        onLog('claude', text)
      }
    }
    return
  }

  // --- Final result ---
  if (event.type === 'result') {
    const cost = event.cost_usd ? `$${event.cost_usd.toFixed(4)}` : ''
    const duration = event.duration_ms ? `${(event.duration_ms / 1000).toFixed(1)}s` : ''
    const parts = [cost, duration].filter(Boolean).join(', ')
    if (parts) onLog('claude', `Done (${parts})`)
  }
}

function logToolUse(name: string, inputJson: string, onLog: (source: string, message: string) => void): void {
  let input: any = {}
  try { input = JSON.parse(inputJson) } catch { /* partial or empty */ }

  if (name === 'Read') {
    onLog('claude', `Reading: ${input.file_path || 'file'}`)
  } else if (name === 'Edit') {
    onLog('claude', `Editing: ${input.file_path || 'file'}`)
  } else if (name === 'Write') {
    onLog('claude', `Writing: ${input.file_path || 'file'}`)
  } else if (name === 'Glob') {
    onLog('claude', `Searching files: ${input.pattern || ''}`)
  } else if (name === 'Grep') {
    onLog('claude', `Searching for: ${input.pattern || ''}`)
  } else {
    onLog('claude', `Tool: ${name}`)
  }
}

async function ensureRepo(repo: string, defaultBranch: string, repoDir: string): Promise<void> {
  if (existsSync(path.join(repoDir, '.git'))) {
    await git(repoDir, ['fetch', 'origin'])
  } else {
    console.log(`[fixer] Cloning ${repo}...`)
    await execFileAsync('gh', ['repo', 'clone', repo, repoDir, '--', '-b', defaultBranch], {
      timeout: 120_000,
    })
  }
}

function git(cwd: string, args: string[]) {
  return execFileAsync('git', args, { cwd, timeout: 60_000 })
}
