import { execFile, spawn } from "child_process";
import { promisify } from "util";
import { existsSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const execFileAsync = promisify(execFile);

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const CLAUDE_BIN = path.resolve(__dirname, "..", "node_modules", ".bin", "claude");
const MODEL = process.env.ANTHROPIC_MODEL || "qwen2.5-coder:14b";

/**
 * Clone or update the repo, then use Claude Code CLI to analyze
 * the Sentry error and produce a fix.
 */
export async function fixIssue({ parsed, projectConfig, reposDir, onLog }) {
  const log = onLog || (() => {});
  const repoDir = path.join(reposDir, projectConfig.repo.replace("/", "__"));
  const branch = `sentry-autofix/${parsed.issueId}`;

  // 1. Clone or pull the repo
  log("git", `Cloning/updating repo ${projectConfig.repo}...`);
  await ensureRepo(projectConfig.repo, projectConfig.branch, repoDir);

  // 2. Create a fresh branch from the default branch
  log("git", `Checking out ${projectConfig.branch} and pulling latest...`);
  await git(repoDir, ["checkout", projectConfig.branch]);
  await git(repoDir, ["pull", "origin", projectConfig.branch]);
  try {
    await git(repoDir, ["branch", "-D", branch]);
  } catch {
    // branch doesn't exist yet, that's fine
  }
  log("git", `Creating branch ${branch}...`);
  await git(repoDir, ["checkout", "-b", branch]);

  // 3. Build the prompt for Claude Code
  const prompt = buildPrompt(parsed, projectConfig);

  // 4. Run Claude Code CLI in the repo directory
  log("claude", `Running Claude Code (${MODEL})...`);
  console.log(`[fixer] Running Claude Code (${MODEL}) for issue ${parsed.issueId}...`);
  const claudeOutput = await runClaudeCode(repoDir, prompt, log);
  log("claude", "Claude Code finished.");
  console.log(`[fixer] Claude Code finished for issue ${parsed.issueId}`);

  // 5. Check what actually changed via git
  const { stdout: diffFiles } = await git(repoDir, ["diff", "--name-only"]);
  const changedFiles = diffFiles.trim().split("\n").filter(Boolean);

  if (changedFiles.length === 0) {
    log("result", "No files changed.");
    console.log(`[fixer] No files changed for issue ${parsed.issueId}`);
    return { success: false, reason: "no_changes" };
  }

  // 6. Stage and commit
  log("git", "Committing changes...");
  await git(repoDir, ["add", "-A"]);
  await git(repoDir, [
    "commit",
    "-m",
    `fix: auto-fix Sentry issue ${parsed.issueId}\n\n${parsed.title}\n\nSentry Issue: ${parsed.webUrl || parsed.issueUrl || "N/A"}\nGenerated by sentry-autofix using Claude Code (${MODEL})`,
  ]);

  // 7. Push the branch
  log("git", `Pushing branch ${branch}...`);
  await git(repoDir, ["push", "origin", branch, "--force-with-lease"]);

  log("result", `Changed files: ${changedFiles.join(", ")}`);

  return {
    success: true,
    branch,
    changedFiles,
    claudeOutput,
  };
}

function buildPrompt(parsed, projectConfig) {
  let prompt = `Fix a production bug in this ${projectConfig.language}/${projectConfig.framework} project.\n\n`;

  prompt += `## Error\n`;
  prompt += `**Title:** ${parsed.title}\n`;
  prompt += `**Level:** ${parsed.level}\n`;

  if (parsed.culprit) {
    prompt += `**Culprit:** ${parsed.culprit}\n`;
  }
  if (parsed.message && parsed.message !== parsed.title) {
    prompt += `**Message:** ${parsed.message}\n`;
  }

  if (parsed.stacktrace) {
    prompt += `\n## Stack Trace\n\`\`\`\n`;
    for (const ex of parsed.stacktrace) {
      prompt += `${ex.type}: ${ex.value}\n`;
      const appFrames = ex.frames.filter((f) => f.inApp);
      const frames = appFrames.length > 0 ? appFrames : ex.frames.slice(-10);
      for (const frame of frames) {
        prompt += `  at ${frame.function || "?"} (${frame.filename}:${frame.lineNo})\n`;
        if (frame.context) {
          prompt += `    > ${frame.context}\n`;
        }
      }
    }
    prompt += `\`\`\`\n`;
  }

  if (parsed.request) {
    prompt += `\n## HTTP Request\n${parsed.request.method} ${parsed.request.url}\n`;
  }

  prompt += `\n## Instructions\n`;
  prompt += `- Read the relevant source files from the stack trace above.\n`;
  prompt += `- Identify and fix the root cause of this error.\n`;
  prompt += `- Edit the files directly to apply your fix.\n`;
  prompt += `- Do not add new dependencies.\n`;
  prompt += `- If you cannot confidently fix the issue, make no changes.\n`;

  return prompt;
}

/**
 * Run Claude Code CLI in the given directory with the prompt.
 * Returns the CLI output text.
 */
async function runClaudeCode(cwd, prompt, log) {
  return new Promise((resolve, reject) => {
    const args = [
      "--print",        // non-interactive mode, output result and exit
      "--model", MODEL,
      "--allowedTools", "Read,Glob,Grep,Edit,Write",
      prompt,
    ];

    let stdout = "";
    let stderr = "";
    let stdoutBuffer = "";
    let stderrBuffer = "";

    const proc = spawn(CLAUDE_BIN, args, {
      cwd,
      timeout: 600_000, // 10 min timeout
      env: {
        ...process.env,
        PATH: process.env.PATH,
      },
    });

    proc.stdout.on("data", (data) => {
      const chunk = data.toString();
      stdout += chunk;
      stdoutBuffer += chunk;
      const lines = stdoutBuffer.split("\n");
      stdoutBuffer = lines.pop(); // keep incomplete last line in buffer
      for (const line of lines) {
        if (line.trim()) log("claude", line);
      }
    });

    proc.stderr.on("data", (data) => {
      const chunk = data.toString();
      stderr += chunk;
      stderrBuffer += chunk;
      const lines = stderrBuffer.split("\n");
      stderrBuffer = lines.pop();
      for (const line of lines) {
        if (line.trim()) log("claude-stderr", line);
      }
    });

    proc.on("close", (code) => {
      // Flush remaining buffers
      if (stdoutBuffer.trim()) log("claude", stdoutBuffer);
      if (stderrBuffer.trim()) log("claude-stderr", stderrBuffer);
      if (code !== 0) {
        console.warn(`[fixer] Claude Code stderr: ${stderr}`);
      }
      resolve(stdout);
    });

    proc.on("error", (err) => {
      log("error", `Failed to run Claude Code: ${err.message}`);
      reject(new Error(`Failed to run Claude Code: ${err.message}`));
    });
  });
}

async function ensureRepo(repo, defaultBranch, repoDir) {
  if (existsSync(path.join(repoDir, ".git"))) {
    await git(repoDir, ["fetch", "origin"]);
  } else {
    console.log(`[fixer] Cloning ${repo}...`);
    await execFileAsync("gh", ["repo", "clone", repo, repoDir, "--", "-b", defaultBranch], {
      timeout: 120_000,
    });
  }
}

function git(cwd, args) {
  return execFileAsync("git", args, { cwd, timeout: 60_000 });
}
