import { execFile } from "child_process";
import { promisify } from "util";
import { existsSync, readFileSync, writeFileSync } from "fs";
import path from "path";

const execFileAsync = promisify(execFile);

const OLLAMA_HOST = process.env.OLLAMA_HOST || "http://host.docker.internal:11434";
const OLLAMA_MODEL = process.env.OLLAMA_MODEL || "qwen2.5";

/**
 * Clone or update the repo, then use Ollama to analyze
 * the Sentry error and produce a fix.
 */
export async function fixIssue({ parsed, projectConfig, reposDir, maxFilesChanged }) {
  const repoDir = path.join(reposDir, projectConfig.repo.replace("/", "__"));
  const branch = `sentry-autofix/${parsed.issueId}`;

  // 1. Clone or pull the repo
  await ensureRepo(projectConfig.repo, projectConfig.branch, repoDir);

  // 2. Create a fresh branch from the default branch
  await git(repoDir, ["checkout", projectConfig.branch]);
  await git(repoDir, ["pull", "origin", projectConfig.branch]);
  try {
    await git(repoDir, ["branch", "-D", branch]);
  } catch {
    // branch doesn't exist yet, that's fine
  }
  await git(repoDir, ["checkout", "-b", branch]);

  // 3. Gather relevant file contents from the stack trace
  const fileContents = gatherFiles(parsed, repoDir);

  if (fileContents.length === 0) {
    console.log(`[fixer] No matching source files found for issue ${parsed.issueId}`);
    return { success: false, reason: "no_source_files" };
  }

  // 4. Build prompt and call Ollama
  const prompt = buildPrompt(parsed, projectConfig, fileContents, maxFilesChanged);

  console.log(`[fixer] Calling Ollama (${OLLAMA_MODEL}) for issue ${parsed.issueId}...`);
  const response = await callOllama(prompt);

  // 5. Parse the response for file edits
  const edits = parseEdits(response);

  if (edits.length === 0) {
    console.log(`[fixer] Ollama returned no edits for issue ${parsed.issueId}`);
    return { success: false, reason: "no_changes" };
  }

  if (edits.length > maxFilesChanged) {
    console.log(`[fixer] Too many files to edit (${edits.length} > ${maxFilesChanged}), aborting`);
    return { success: false, reason: "too_many_files" };
  }

  // 6. Apply the edits
  let appliedCount = 0;
  for (const edit of edits) {
    const filePath = path.resolve(repoDir, edit.file);
    // Safety: ensure the file is within the repo
    if (!filePath.startsWith(repoDir)) {
      console.warn(`[fixer] Skipping edit outside repo: ${edit.file}`);
      continue;
    }
    try {
      writeFileSync(filePath, edit.content, "utf8");
      appliedCount++;
      console.log(`[fixer] Applied edit to ${edit.file}`);
    } catch (err) {
      console.warn(`[fixer] Failed to write ${edit.file}: ${err.message}`);
    }
  }

  if (appliedCount === 0) {
    return { success: false, reason: "no_changes" };
  }

  // 7. Check what actually changed via git
  const { stdout: diffFiles } = await git(repoDir, ["diff", "--name-only"]);
  const changedFiles = diffFiles.trim().split("\n").filter(Boolean);
  if (changedFiles.length === 0) {
    return { success: false, reason: "no_changes" };
  }

  // 8. Stage and commit
  await git(repoDir, ["add", "-A"]);
  await git(repoDir, [
    "commit",
    "-m",
    `fix: auto-fix Sentry issue ${parsed.issueId}\n\n${parsed.title}\n\nSentry Issue: ${parsed.webUrl || parsed.issueUrl || "N/A"}\nGenerated by sentry-autofix using Ollama (${OLLAMA_MODEL})`,
  ]);

  // 9. Push the branch
  await git(repoDir, ["push", "origin", branch, "--force-with-lease"]);

  return {
    success: true,
    branch,
    changedFiles,
    ollamaOutput: response,
  };
}

/**
 * Gather source files referenced in the stack trace.
 * Reads in-app frames and tries to find matching files in the repo.
 */
function gatherFiles(parsed, repoDir) {
  const files = new Map();

  if (!parsed.stacktrace) return [];

  for (const ex of parsed.stacktrace) {
    for (const frame of ex.frames) {
      if (!frame.filename) continue;

      // Normalize the filename - strip common prefixes
      let relPath = frame.filename
        .replace(/^\/?(app|src|var\/www|html)\//i, "")
        .replace(/^\/?/, "");

      // Try to find the file in the repo with common path resolutions
      const candidates = [
        relPath,
        `src/${relPath}`,
        `app/${relPath}`,
        frame.filename,
        frame.absPath,
      ].filter(Boolean);

      for (const candidate of candidates) {
        const fullPath = path.resolve(repoDir, candidate);
        if (fullPath.startsWith(repoDir) && existsSync(fullPath) && !files.has(candidate)) {
          try {
            const content = readFileSync(fullPath, "utf8");
            // Skip very large files
            if (content.length < 50_000) {
              files.set(candidate, { path: candidate, content, lineNo: frame.lineNo });
            }
          } catch {
            // skip unreadable files
          }
          break;
        }
      }
    }
  }

  return [...files.values()];
}

function buildPrompt(parsed, projectConfig, fileContents, maxFilesChanged) {
  let prompt = `You are an expert ${projectConfig.language}/${projectConfig.framework} developer fixing a production bug.\n\n`;

  prompt += `## Error\n`;
  prompt += `**Title:** ${parsed.title}\n`;
  prompt += `**Level:** ${parsed.level}\n`;

  if (parsed.culprit) {
    prompt += `**Culprit:** ${parsed.culprit}\n`;
  }
  if (parsed.message && parsed.message !== parsed.title) {
    prompt += `**Message:** ${parsed.message}\n`;
  }

  if (parsed.stacktrace) {
    prompt += `\n## Stack Trace\n\`\`\`\n`;
    for (const ex of parsed.stacktrace) {
      prompt += `${ex.type}: ${ex.value}\n`;
      const appFrames = ex.frames.filter((f) => f.inApp);
      const frames = appFrames.length > 0 ? appFrames : ex.frames.slice(-10);
      for (const frame of frames) {
        prompt += `  at ${frame.function || "?"} (${frame.filename}:${frame.lineNo})\n`;
        if (frame.context) {
          prompt += `    > ${frame.context}\n`;
        }
      }
    }
    prompt += `\`\`\`\n`;
  }

  if (parsed.request) {
    prompt += `\n## HTTP Request\n${parsed.request.method} ${parsed.request.url}\n`;
  }

  prompt += `\n## Source Files\n`;
  for (const file of fileContents) {
    prompt += `\n### ${file.path}\n`;
    if (file.lineNo) {
      prompt += `(Error at line ${file.lineNo})\n`;
    }
    prompt += `\`\`\`\n${file.content}\n\`\`\`\n`;
  }

  prompt += `\n## Instructions\n`;
  prompt += `Fix the root cause of this error. Respond with ONLY the fixed files using this exact format for each file:\n\n`;
  prompt += `FILE: path/to/file.ext\n`;
  prompt += `\`\`\`\n`;
  prompt += `<entire fixed file content>\n`;
  prompt += `\`\`\`\n\n`;
  prompt += `Rules:\n`;
  prompt += `- Output the COMPLETE file contents, not just the changed parts.\n`;
  prompt += `- Only include files that need changes.\n`;
  prompt += `- Change at most ${maxFilesChanged} files.\n`;
  prompt += `- Do not add new dependencies.\n`;
  prompt += `- If you cannot confidently fix the issue, respond with: NO_FIX\n`;

  return prompt;
}

/**
 * Parse Ollama response to extract file edits.
 * Expected format:
 *   FILE: path/to/file.ext
 *   ```
 *   <content>
 *   ```
 */
function parseEdits(response) {
  const edits = [];
  const regex = /FILE:\s*(.+?)\s*\n```[\w]*\n([\s\S]*?)```/g;
  let match;

  while ((match = regex.exec(response)) !== null) {
    const file = match[1].trim();
    const content = match[2];
    if (file && content && !file.includes("..")) {
      edits.push({ file, content });
    }
  }

  return edits;
}

async function callOllama(prompt) {
  const url = `${OLLAMA_HOST}/api/generate`;

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      model: OLLAMA_MODEL,
      prompt,
      stream: false,
      options: {
        temperature: 0.1,
        num_predict: 8192,
      },
    }),
    signal: AbortSignal.timeout(300_000), // 5 min timeout
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Ollama error ${res.status}: ${text}`);
  }

  const data = await res.json();
  return data.response;
}

async function ensureRepo(repo, defaultBranch, repoDir) {
  if (existsSync(path.join(repoDir, ".git"))) {
    await git(repoDir, ["fetch", "origin"]);
  } else {
    console.log(`[fixer] Cloning ${repo}...`);
    await execFileAsync("gh", ["repo", "clone", repo, repoDir, "--", "-b", defaultBranch], {
      timeout: 120_000,
    });
  }
}

function git(cwd, args) {
  return execFileAsync("git", args, { cwd, timeout: 60_000 });
}
