import { execFile, spawn } from "child_process";
import { promisify } from "util";
import { existsSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const execFileAsync = promisify(execFile);

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const CLAUDE_BIN = path.resolve(__dirname, "..", "node_modules", ".bin", "claude");
const MODEL = process.env.ANTHROPIC_MODEL || "qwen2.5-coder:14b";

/**
 * Clone or update the repo, then use Claude Code CLI to analyze
 * the Sentry error and produce a fix.
 */
export async function fixIssue({ parsed, projectConfig, reposDir, onLog }) {
  const log = onLog || (() => {});
  const repoDir = path.join(reposDir, projectConfig.repo.replace("/", "__"));
  const branch = `sentry-autofix/${parsed.issueId}`;

  // 1. Clone or pull the repo
  log("git", `Cloning/updating repo ${projectConfig.repo}...`);
  await ensureRepo(projectConfig.repo, projectConfig.branch, repoDir);

  // 2. Create a fresh branch from the default branch
  log("git", `Checking out ${projectConfig.branch} and pulling latest...`);
  await git(repoDir, ["checkout", projectConfig.branch]);
  await git(repoDir, ["pull", "origin", projectConfig.branch]);
  try {
    await git(repoDir, ["branch", "-D", branch]);
  } catch {
    // branch doesn't exist yet, that's fine
  }
  log("git", `Creating branch ${branch}...`);
  await git(repoDir, ["checkout", "-b", branch]);

  // 3. Build the prompt for Claude Code
  const prompt = buildPrompt(parsed, projectConfig);

  // 4. Run Claude Code CLI in the repo directory
  log("claude", `Running Claude Code (${MODEL})...`);
  console.log(`[fixer] Running Claude Code (${MODEL}) for issue ${parsed.issueId}...`);
  const claudeOutput = await runClaudeCode(repoDir, prompt, log);
  log("claude", "Claude Code finished.");
  console.log(`[fixer] Claude Code finished for issue ${parsed.issueId}`);

  // 5. Check what actually changed via git
  const { stdout: diffFiles } = await git(repoDir, ["diff", "--name-only"]);
  const changedFiles = diffFiles.trim().split("\n").filter(Boolean);

  if (changedFiles.length === 0) {
    log("result", "No files changed.");
    console.log(`[fixer] No files changed for issue ${parsed.issueId}`);
    return { success: false, reason: "no_changes" };
  }

  // 6. Stage and commit
  log("git", "Committing changes...");
  await git(repoDir, ["add", "-A"]);
  await git(repoDir, [
    "commit",
    "-m",
    `fix: auto-fix Sentry issue ${parsed.issueId}\n\n${parsed.title}\n\nSentry Issue: ${parsed.webUrl || parsed.issueUrl || "N/A"}\nGenerated by sentry-autofix using Claude Code (${MODEL})`,
  ]);

  // 7. Push the branch
  log("git", `Pushing branch ${branch}...`);
  await git(repoDir, ["push", "origin", branch, "--force-with-lease"]);

  log("result", `Changed files: ${changedFiles.join(", ")}`);

  return {
    success: true,
    branch,
    changedFiles,
    claudeOutput,
  };
}

function buildPrompt(parsed, projectConfig) {
  let prompt = `Fix a production bug in this ${projectConfig.language}/${projectConfig.framework} project.\n\n`;

  prompt += `## Error\n`;
  prompt += `**Title:** ${parsed.title}\n`;
  prompt += `**Level:** ${parsed.level}\n`;

  if (parsed.culprit) {
    prompt += `**Culprit:** ${parsed.culprit}\n`;
  }
  if (parsed.message && parsed.message !== parsed.title) {
    prompt += `**Message:** ${parsed.message}\n`;
  }

  if (parsed.stacktrace) {
    prompt += `\n## Stack Trace\n\`\`\`\n`;
    for (const ex of parsed.stacktrace) {
      prompt += `${ex.type}: ${ex.value}\n`;
      const appFrames = ex.frames.filter((f) => f.inApp);
      const frames = appFrames.length > 0 ? appFrames : ex.frames.slice(-10);
      for (const frame of frames) {
        prompt += `  at ${frame.function || "?"} (${frame.filename}:${frame.lineNo})\n`;
        if (frame.context) {
          prompt += `    > ${frame.context}\n`;
        }
      }
    }
    prompt += `\`\`\`\n`;
  }

  if (parsed.request) {
    prompt += `\n## HTTP Request\n${parsed.request.method} ${parsed.request.url}\n`;
  }

  prompt += `\n## Instructions\n`;
  prompt += `- Read the relevant source files from the stack trace above.\n`;
  prompt += `- Identify and fix the root cause of this error.\n`;
  prompt += `- Edit the files directly to apply your fix.\n`;
  prompt += `- Do not add new dependencies.\n`;
  prompt += `- If you cannot confidently fix the issue, make no changes.\n`;

  return prompt;
}

/**
 * Run Claude Code CLI in the given directory with the prompt.
 * Returns the CLI output text.
 */
async function runClaudeCode(cwd, prompt, log) {
  return new Promise((resolve, reject) => {
    const args = [
      "--print",
      "--output-format", "stream-json",
      "--verbose",
      "--include-partial-messages",
      "--model", MODEL,
      "--allowedTools", "Read,Glob,Grep,Edit,Write",
      prompt,
    ];

    let resultText = "";
    let stderr = "";
    let stdoutBuffer = "";
    let stderrBuffer = "";

    const proc = spawn(CLAUDE_BIN, args, {
      cwd,
      timeout: 600_000,
      env: {
        ...process.env,
        PATH: process.env.PATH,
      },
    });

    proc.stdout.on("data", (data) => {
      stdoutBuffer += data.toString();
      const lines = stdoutBuffer.split("\n");
      stdoutBuffer = lines.pop();
      for (const line of lines) {
        if (!line.trim()) continue;
        try {
          const event = JSON.parse(line);
          parseClaudeEvent(event, log);
          // Capture final result text
          if (event.type === "result" && event.result) {
            resultText = event.result;
          }
        } catch {
          // Non-JSON line, log it as-is
          log("claude", line);
        }
      }
    });

    proc.stderr.on("data", (data) => {
      const chunk = data.toString();
      stderr += chunk;
      stderrBuffer += chunk;
      const lines = stderrBuffer.split("\n");
      stderrBuffer = lines.pop();
      for (const line of lines) {
        if (line.trim()) log("claude-stderr", line);
      }
    });

    proc.on("close", (code) => {
      // Flush remaining buffers
      if (stdoutBuffer.trim()) {
        try {
          const event = JSON.parse(stdoutBuffer);
          parseClaudeEvent(event, log);
          if (event.type === "result" && event.result) resultText = event.result;
        } catch {
          log("claude", stdoutBuffer);
        }
      }
      if (stderrBuffer.trim()) log("claude-stderr", stderrBuffer);
      if (code !== 0) {
        console.warn(`[fixer] Claude Code stderr: ${stderr}`);
      }
      resolve(resultText);
    });

    proc.on("error", (err) => {
      log("error", `Failed to run Claude Code: ${err.message}`);
      reject(new Error(`Failed to run Claude Code: ${err.message}`));
    });
  });
}

// Track partial tool_use inputs as they stream in
const pendingToolUse = { name: null, inputJson: "" };

function parseClaudeEvent(event, log) {
  // --- Streaming delta events (from --verbose --include-partial-messages) ---
  if (event.type === "stream_event") {
    const inner = event.event || {};

    // content_block_start: a new content block begins (text or tool_use)
    if (inner.type === "content_block_start" && inner.content_block) {
      const block = inner.content_block;
      if (block.type === "tool_use") {
        pendingToolUse.name = block.name || null;
        pendingToolUse.inputJson = "";
      }
    }

    // content_block_delta: streaming text or tool input
    if (inner.type === "content_block_delta" && inner.delta) {
      // We don't log text deltas individually — too noisy
      // But we accumulate tool input JSON
      if (inner.delta.type === "input_json_delta" && inner.delta.partial_json) {
        pendingToolUse.inputJson += inner.delta.partial_json;
      }
    }

    // content_block_stop: block is complete — log tool calls here
    if (inner.type === "content_block_stop") {
      if (pendingToolUse.name) {
        logToolUse(pendingToolUse.name, pendingToolUse.inputJson, log);
        pendingToolUse.name = null;
        pendingToolUse.inputJson = "";
      }
    }

    return;
  }

  // --- Complete message events (non-streaming fallback) ---
  if (event.type === "message" && event.message?.content) {
    for (const block of event.message.content) {
      if (block.type === "tool_use") {
        logToolUse(block.name, JSON.stringify(block.input || {}), log);
      } else if (block.type === "text" && block.text) {
        const text = block.text.length > 200 ? block.text.slice(0, 200) + "..." : block.text;
        log("claude", text);
      }
    }
    return;
  }

  // --- Final result ---
  if (event.type === "result") {
    const cost = event.cost_usd ? `$${event.cost_usd.toFixed(4)}` : "";
    const duration = event.duration_ms ? `${(event.duration_ms / 1000).toFixed(1)}s` : "";
    const parts = [cost, duration].filter(Boolean).join(", ");
    if (parts) log("claude", `Done (${parts})`);
  }
}

function logToolUse(name, inputJson, log) {
  let input = {};
  try { input = JSON.parse(inputJson); } catch { /* partial or empty */ }

  if (name === "Read") {
    log("claude", `Reading: ${input.file_path || "file"}`);
  } else if (name === "Edit") {
    log("claude", `Editing: ${input.file_path || "file"}`);
  } else if (name === "Write") {
    log("claude", `Writing: ${input.file_path || "file"}`);
  } else if (name === "Glob") {
    log("claude", `Searching files: ${input.pattern || ""}`);
  } else if (name === "Grep") {
    log("claude", `Searching for: ${input.pattern || ""}`);
  } else {
    log("claude", `Tool: ${name}`);
  }
}

async function ensureRepo(repo, defaultBranch, repoDir) {
  if (existsSync(path.join(repoDir, ".git"))) {
    await git(repoDir, ["fetch", "origin"]);
  } else {
    console.log(`[fixer] Cloning ${repo}...`);
    await execFileAsync("gh", ["repo", "clone", repo, repoDir, "--", "-b", defaultBranch], {
      timeout: 120_000,
    });
  }
}

function git(cwd, args) {
  return execFileAsync("git", args, { cwd, timeout: 60_000 });
}
