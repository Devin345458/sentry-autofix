import { execFile, spawn } from "child_process";
import { promisify } from "util";
import { existsSync } from "fs";
import path from "path";

const execFileAsync = promisify(execFile);

/**
 * Clone or update the repo, then invoke Claude Code CLI to analyze
 * the Sentry error and produce a fix.
 */
export async function fixIssue({ parsed, projectConfig, reposDir, maxFilesChanged }) {
  const repoDir = path.join(reposDir, projectConfig.repo.replace("/", "__"));
  const branch = `sentry-autofix/${parsed.issueId}`;

  // 1. Clone or pull the repo
  await ensureRepo(projectConfig.repo, projectConfig.branch, repoDir);

  // 2. Create a fresh branch from the default branch
  await git(repoDir, ["checkout", projectConfig.branch]);
  await git(repoDir, ["pull", "origin", projectConfig.branch]);
  try {
    await git(repoDir, ["branch", "-D", branch]);
  } catch {
    // branch doesn't exist yet, that's fine
  }
  await git(repoDir, ["checkout", "-b", branch]);

  // 3. Build the prompt for Claude Code
  const prompt = buildPrompt(parsed, projectConfig, maxFilesChanged);

  // 4. Run Claude Code CLI
  console.log(`[fixer] Running Claude Code for issue ${parsed.issueId}...`);
  const result = await runClaudeCode(repoDir, prompt);

  // 5. Check if any files were actually changed
  const { stdout: diffStat } = await git(repoDir, ["diff", "--stat"]);
  if (!diffStat.trim()) {
    console.log(`[fixer] Claude Code made no changes for issue ${parsed.issueId}`);
    return { success: false, reason: "no_changes" };
  }

  // 6. Check file count limit
  const { stdout: diffFiles } = await git(repoDir, ["diff", "--name-only"]);
  const changedFiles = diffFiles.trim().split("\n").filter(Boolean);
  if (changedFiles.length > maxFilesChanged) {
    console.log(`[fixer] Too many files changed (${changedFiles.length} > ${maxFilesChanged}), aborting`);
    await git(repoDir, ["checkout", "."]);
    return { success: false, reason: "too_many_files" };
  }

  // 7. Stage and commit
  await git(repoDir, ["add", "-A"]);
  await git(repoDir, [
    "commit",
    "-m",
    `fix: auto-fix Sentry issue ${parsed.issueId}\n\n${parsed.title}\n\nSentry Issue: ${parsed.webUrl || parsed.issueUrl || "N/A"}\nGenerated by sentry-autofix using Claude Code`,
  ]);

  // 8. Push the branch
  await git(repoDir, ["push", "origin", branch, "--force-with-lease"]);

  return {
    success: true,
    branch,
    changedFiles,
    claudeOutput: result,
  };
}

function buildPrompt(parsed, projectConfig, maxFilesChanged) {
  let prompt = `You are fixing a production bug reported by Sentry. Here is the error:\n\n`;
  prompt += `**Error:** ${parsed.title}\n`;
  prompt += `**Level:** ${parsed.level}\n`;
  prompt += `**Platform:** ${parsed.platform || projectConfig.language}\n`;
  prompt += `**Framework:** ${projectConfig.framework}\n`;

  if (parsed.culprit) {
    prompt += `**Culprit:** ${parsed.culprit}\n`;
  }

  if (parsed.message && parsed.message !== parsed.title) {
    prompt += `**Message:** ${parsed.message}\n`;
  }

  if (parsed.stacktrace) {
    prompt += `\n**Stack Trace:**\n\`\`\`\n`;
    for (const ex of parsed.stacktrace) {
      prompt += `${ex.type}: ${ex.value}\n`;
      const appFrames = ex.frames.filter((f) => f.inApp);
      const frames = appFrames.length > 0 ? appFrames : ex.frames.slice(-10);
      for (const frame of frames) {
        prompt += `  at ${frame.function || "?"} (${frame.filename}:${frame.lineNo})\n`;
        if (frame.context) {
          prompt += `    > ${frame.context}\n`;
        }
      }
    }
    prompt += `\`\`\`\n`;
  }

  if (parsed.request) {
    prompt += `\n**HTTP Request:** ${parsed.request.method} ${parsed.request.url}\n`;
  }

  prompt += `\n**Instructions:**\n`;
  prompt += `- Find and fix the root cause of this error.\n`;
  prompt += `- Only modify files that are directly related to the fix.\n`;
  prompt += `- Change at most ${maxFilesChanged} files.\n`;
  prompt += `- Do not add new dependencies.\n`;
  prompt += `- Do not refactor or improve unrelated code.\n`;
  prompt += `- If you cannot confidently fix the issue, make no changes.\n`;

  return prompt;
}

async function ensureRepo(repo, defaultBranch, repoDir) {
  if (existsSync(path.join(repoDir, ".git"))) {
    await git(repoDir, ["fetch", "origin"]);
  } else {
    console.log(`[fixer] Cloning ${repo}...`);
    await execFileAsync("gh", ["repo", "clone", repo, repoDir, "--", "-b", defaultBranch], {
      timeout: 120_000,
    });
  }
}

function git(cwd, args) {
  return execFileAsync("git", args, { cwd, timeout: 60_000 });
}

function runClaudeCode(cwd, prompt) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    const proc = spawn("claude", ["-p", prompt, "--allowedTools", "Read,Glob,Grep,Edit,Write"], {
      cwd,
      timeout: 300_000, // 5 minute timeout
      stdio: ["ignore", "pipe", "pipe"],
    });

    proc.stdout.on("data", (data) => chunks.push(data));
    proc.stderr.on("data", (data) => {
      console.error(`[claude stderr] ${data.toString().trim()}`);
    });

    proc.on("close", (code) => {
      const output = Buffer.concat(chunks).toString("utf8");
      if (code !== 0) {
        reject(new Error(`Claude Code exited with code ${code}: ${output.slice(0, 500)}`));
      } else {
        resolve(output);
      }
    });

    proc.on("error", reject);
  });
}
